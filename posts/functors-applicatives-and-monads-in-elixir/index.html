<!DOCTYPE html><html lang="en"><meta charset="utf-8"><meta content="IE=edge"http-equiv="X-UA-Compatible"><meta content="width=device-width,minimum-scale=1,initial-scale=1"name="viewport"><link href=""rel="shortcut icon"type="image/x-icon"><link href=""rel="icon"type="image/x-icon"><title>Functors, Applicatives, and Monads in Elixir - Shane Logsdon</title><meta content="Functors, Applicatives, and Monads in Elixir"property="og:title"><meta content="Elixir doesn't have native modules for functors, applicatives, and monads. Is it possible to create them? Is it worth it?"name="description"><meta content="Elixir doesn't have native modules for functors, applicatives, and monads. Is it possible to create them? Is it worth it?"property="og:description"><link href="https://shane.logsdon.io/posts/functors-applicatives-and-monads-in-elixir/"rel="canonical"><meta content="https://shane.logsdon.io/posts/functors-applicatives-and-monads-in-elixir/"property="og:url"><meta content="Shane Logsdon"property="og:site_name"><meta content="https://shane.logsdon.io//assets/images/side-of-building.jpeg"property="og:image"><meta content="article"property="og:type"><meta content="2015-10-04T04:00:00.000Z"property="article:published_time"><link href="https://shane.logsdon.io/posts/functional-programming-principles-in-elixir/"rel="next"title="Functional Programming Principles in Elixir"><meta content="summary_large_image"name="twitter:card"><meta content="@shanelogsdon"name="twitter:site"><meta content="@shanelogsdon"name="twitter:creator"><script type="application/ld+json">{"@context": "http://schema.org","@type": "BlogPosting","headline": "Functors, Applicatives, and Monads in Elixir","image": "https://shane.logsdon.io//assets/images/side-of-building.jpeg","datePublished": "2015-10-04T04:00:00.000Z","dateModified": "2015-10-04T04:00:00.000Z","description": "Elixir doesn&#39;t have native modules for functors, applicatives, and monads. Is it possible to create them? Is it worth it?","author": {"@type": "Person","name": "Shane Logsdon","image": "https://s.gravatar.com/avatar/033132c341296d7f5e5b41e871178418?s=60"},"publisher": {"@type": "Organization","name": "Shane Logsdon","logo": {"@type": "ImageObject","url": "https://s.gravatar.com/avatar/033132c341296d7f5e5b41e871178418?s=60","width": "60","height": "60"}},"mainEntityOfPage": "https://shane.logsdon.io/posts/functors-applicatives-and-monads-in-elixir/","url": "https://shane.logsdon.io/posts/functors-applicatives-and-monads-in-elixir/"}</script><link href=""rel="alternate"type="application/rss+xml"title="Shane Logsdon"><style>.dn{display:none}.sans-serif{font-family:-apple-system,BlinkMacSystemFont,avenir next,avenir,helvetica,helvetica neue,ubuntu,roboto,noto,segoe ui,arial,sans-serif}.normal{font-weight:400}.b{font-weight:700}.lh-copy{line-height:1.5}.tl{text-align:left}.tc{text-align:center}.f2{font-size:2.25rem}.f4{font-size:1.25rem}.f6{font-size:.875rem}.measure{max-width:30em}.di{display:inline}.db{display:block}.dib{display:inline-block}.pl1{padding-left:.25rem}.pb3{padding-bottom:1rem}.pv2{padding-top:.5rem;padding-bottom:.5rem}.ma1{margin:.25rem}.ma3{margin:1rem}.mb1,.mv1{margin-bottom:.25rem}.mr3{margin-right:1rem}.mt3{margin-top:1rem}.mv1{margin-top:.25rem}.mv3{margin-top:1rem;margin-bottom:1rem}.mv4{margin-top:2rem;margin-bottom:2rem}.w-100{width:100%}.ba{border-style:solid;border-width:1px}.bt{border-top-style:solid;border-top-width:1px}.bb{border-bottom-style:solid;border-bottom-width:1px}.b--black-10{border-color:rgba(0,0,0,.1)}.black-70{color:rgba(0,0,0,.7)}.black-50{color:rgba(0,0,0,.5)}.black-30{color:rgba(0,0,0,.3)}.list{list-style-type:none}@media screen and (min-width:30em){.v-top-ns{vertical-align:top}.dib-ns{display:inline-block}}@media screen and (min-width:60em){.f1-l{font-size:3rem}.f3-l{font-size:1.5rem}.dn-l{display:none}.dib-l{display:inline-block}.ml3-l{margin-left:1rem}.ml4-l{margin-left:2rem}.mt1-l{margin-top:.25rem}.mv4-l{margin-top:2rem;margin-bottom:2rem}.mv5-l{margin-top:4rem;margin-bottom:4rem}.w-20-l{width:20%}.w-50-l{width:50%}.bn-l{border-style:none;border-width:0}}</style><body class="fira-code sans-serif"><div class="w-100 dib-l ml4-l sub-header w-50-l"><div class="b--black-10 tc w-100 ba dn-l"><a href="#menu"class="w-100 black-30 db pv2">menu</a></div><main class="content"><article class="post"itemscope itemtype="http://schema.org/BlogPosting"><header class="header"><meta itemprop="mainEntityOfPage"itemtype="https://schema.org/WebPage"itemid="https://shane.logsdon.io/posts/functors-applicatives-and-monads-in-elixir/"itemscope><h1 class="title f1-l f2 lh-title mb1 measure-wide mt4"itemprop="name headline">Functors, Applicatives, and Monads in Elixir</h1><div class="meta"><time class="f6 black-50"datetime="2015-10-04T04:00:00.000Z"itemprop="datePublished">Published: Oct 4th, 2015 </time><time class="f6 black-50"datetime="2017-01-31T06:17:08.000Z"itemprop="dateModified"></time> <span itemprop="author"itemscope itemtype="http://schema.org/Person"><meta content="Shane Logsdon"itemprop="name"></span><span itemprop="publisher"itemscope itemtype="http://schema.org/Organization"><meta content="Shane Logsdon"itemprop="name"><span itemprop="logo"itemscope itemtype="http://schema.org/ImageObject"><meta content="https://s.gravatar.com/avatar/033132c341296d7f5e5b41e871178418?s=60"itemprop="url"><meta content="60"itemprop="width"itemtype="https://schema.org/Distance"><meta content="60"itemprop="height"itemtype="https://schema.org/Distance"></span></span><span itemprop="image"itemscope itemtype="http://schema.org/ImageObject"><meta content="https://s.gravatar.com/avatar/033132c341296d7f5e5b41e871178418?s=60"itemprop="url"><meta content="60"itemprop="width"itemtype="https://schema.org/Distance"><meta content="60"itemprop="height"itemtype="https://schema.org/Distance"></span></div></header><section class="content lh-copy"itemprop="articleBody"><blockquote><p><strong>Big ol’ note:</strong> By no means am I an expert on any of the below content. I’m currently learning this to the best of my ability and thought to write down my experiences and thoughts with implementing these in Elixir.</blockquote><p>We’re going to be comparing Elixir protocols with Haskell’s type classes using a go-to type for the subject at hand: <code>Maybe</code>. The <code>Maybe</code> type encapsulates an optional value. A value of type <code>Maybe a</code> either contains a value of type <code>a</code> (represented as <code>Just a</code>), or it is empty (represented as <code>Nothing</code>). Here’s how Haskell defines the type:<figure class="highlight haskell"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">data</span> <span class="type">Maybe</span> a = <span class="type">Just</span> a</span></div><div class="line">             | <span class="type">Nothing</span></div></pre></table></figure><p>Because of Elixir’s lack of strong typing and type constructors, we define the Elixir version of <code>Maybe</code> slightly different:<figure class="highlight elixir"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Maybe</span></span> <span class="keyword">do</span></div><div class="line">  <span class="variable">@type</span> t <span class="symbol">:</span>: %__MODULE_<span class="number">_</span>{</div><div class="line">    <span class="symbol">just:</span> term,</div><div class="line">    <span class="symbol">nothing:</span> boolean</div><div class="line">  }</div><div class="line">  defstruct <span class="symbol">just:</span> <span class="keyword">nil</span>,</div><div class="line">            <span class="symbol">nothing:</span> <span class="keyword">false</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">just</span></span>(v), <span class="symbol">do:</span> __MODULE_<span class="number">_</span> |> struct(<span class="symbol">just:</span> v)</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">nothing</span></span>, <span class="symbol">do:</span> __MODULE_<span class="number">_</span> |> struct(<span class="symbol">nothing:</span> <span class="keyword">true</span>)</div><div class="line"><span class="keyword">end</span></div></pre></table></figure><p>The struct is acting as a wrapper for the values and the module contains some helper functions to act as a pseudo-replacement for Haskell’s type constructors. In Elixir, the type <code>Maybe a</code> now either contains a value of type <code>term</code> (represented as <code>Maybe.just(term)</code>) or is empty (represented as <code>Maybe.nothing</code>).<h2 id="Functor"><a href="#Functor"class="headerlink"title="Functor"></a>Functor</h2><p>Using functors, we can generalize how <code>Enum.map</code> works for <code>Enumerable</code>s on any data type, including <code>Maybe</code>. We can accomplish this by generalizing the action and implementing that action for the desired data types. This generalized action for Functors is known as <code>fmap</code>. Take a look at the definition for the <code>Functor</code> protocol:<figure class="highlight elixir"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defprotocol</span> <span class="title">Functor</span></span> <span class="keyword">do</span></div><div class="line">  <span class="variable">@spec</span> fmap(t, (term -> term)) <span class="symbol">:</span>: t</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">fmap</span></span>(functor, fun)</div><div class="line"><span class="keyword">end</span></div></pre></table></figure><p>and compare it to Haskell’s <code>Functor</code> type class:<figure class="highlight haskell"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="type">Functor</span> f <span class="keyword">where</span></span></div><div class="line">    fmap :: (a -> b) -> f a -> f b</div></pre></table></figure><p>We can start to see similarities between the two purely by looking at the types. Both require a functor and function as arguments. Haskell’s <code>f a</code> represents a functor with a type constructor of <code>a</code>, similar to <code>[a]</code> being a list of <code>a</code>s. You may notice that the order of the arguments in both differ. This mostly has to do with how Elixir’s Protocol dispatch process works as it looks at the first argument’s type in order to dispatch the call to the correct implementation.<p>Now, any type that wishes to be a functor only needs to implement the <code>fmap</code> function, using Elixir’s <code>defimpl</code> macro or Haskell’s <code>instance</code> keyword:<figure class="highlight elixir"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defimpl</span> <span class="title">Functor</span></span>, <span class="symbol">for:</span> Maybe <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">fmap</span></span>(%{<span class="symbol">nothing:</span> <span class="keyword">true</span>} = f, <span class="number">_</span>), <span class="symbol">do:</span> f</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">fmap</span></span>(%{<span class="symbol">just:</span> a}, fun) <span class="keyword">do</span></div><div class="line">    fun</div><div class="line">    |> apply([a])</div><div class="line">    |> Maybe.just</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></table></figure><figure class="highlight haskell"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Functor</span> <span class="type">Maybe</span>  <span class="keyword">where</span></span></div><div class="line">    fmap _ <span class="type">Nothing</span>  = <span class="type">Nothing</span></div><div class="line">    fmap f (<span class="type">Just</span> a) = <span class="type">Just</span> (f a)</div></pre></table></figure><p>While the Haskell version is more concise, they both define the same core functionality. Calling <code>fmap</code> on a “nothing” will always return a “nothing”, ignoring the function that is passed as well. Calling <code>fmap</code> on a value will unwrap the value by pattern matching the <code>Maybe</code> functor and applying the passed function on the value.<h3 id="Defining-and-Using-Functors"><a href="#Defining-and-Using-Functors"class="headerlink"title="Defining and Using Functors"></a>Defining and Using Functors</h3><p>Let’s take a look at what this looks like in use:<figure class="highlight elixir"><table><tr><td class="code"><pre><div class="line">f<span class="number">0</span> = <span class="keyword">fn</span> x -> x + <span class="number">2</span> <span class="keyword">end</span></div><div class="line"></div><div class="line">Maybe.just(<span class="number">5</span>)      <span class="comment"># Define</span></div><div class="line">|> Functor.fmap(f<span class="number">0</span>) <span class="comment"># Use</span></div><div class="line"><span class="comment"># %Maybe{just: 7, nothing: false}</span></div></pre></table></figure><p>Since our functors in Elixir are just simple structs, our “Just 5” value can be defined in the same variety of ways: <code>Maybe.just(5)</code>, <code>%Maybe{just: 5}</code>, <code>struct(Maybe, just: 5)</code>, etc. The power of the functor comes from the <code>Functor</code> protocol. When we want to work with the functor, we pass it to <code>fmap/2</code> along with a function, in this case a small anonymous function that adds <code>2</code>. From here, Elixir’s protocol dispatch takes over, inspecting the functor’s type to direct the call to the functor’s implementation of <code>fmap/2</code>.<p>The result of <code>fmap/2</code> is another functor, so if necessary, we can continue to pipe additional calls to <code>fmap/2</code>. At any time during this pipeline, any one of the included functions could potentially return a “nothing” value (<code>Maybe.nothing</code>) without throwing an error.<figure class="highlight elixir"><table><tr><td class="code"><pre><div class="line">f1 = <span class="keyword">fn</span> x-> x + <span class="number">2</span> <span class="keyword">end</span></div><div class="line">f2 = <span class="keyword">fn</span> <span class="number">_</span> -> Maybe.nothing <span class="keyword">end</span></div><div class="line">f3 = <span class="keyword">fn</span> x -> x * <span class="number">3</span> <span class="keyword">end</span></div><div class="line"></div><div class="line">Maybe.just(<span class="number">5</span>)</div><div class="line">|> Functor.fmap(f1)</div><div class="line">|> Functor.fmap(f2)</div><div class="line">|> Functor.fmap(f3)</div><div class="line"><span class="comment"># %Maybe{just: nil, nothing: true}</span></div></pre></table></figure><p>In a real world situation, this allows us to worry less about catching and accounting for possible points of failure since our implementation of <code>Functor</code> for <code>Maybe</code> already accounts for this case (remember, calling <code>fmap</code> on a “nothing” will always return a “nothing”).<h2 id="Applicative-Functor"><a href="#Applicative-Functor"class="headerlink"title="Applicative (Functor)"></a>Applicative (Functor)</h2><blockquote><p><em>I’m going to leave out the Haskell from here until I can figure how to handle a few things better in Elixir.</em></blockquote><p>Applicatives (or more specifically applicative functors) are a special form of <code>Functor</code> where the value within the functor is a function.<figure class="highlight elixir"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defprotocol</span> <span class="title">Applicative</span></span> <span class="keyword">do</span></div><div class="line">  <span class="variable">@spec</span> apply(t, Functor.t) <span class="symbol">:</span>: t</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(fun, f)</div><div class="line"><span class="keyword">end</span></div><div class="line"><span class="class"><span class="keyword">defimpl</span> <span class="title">Applicative</span></span>, <span class="symbol">for:</span> Maybe <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(%{<span class="symbol">nothing:</span> <span class="keyword">true</span>} = f, <span class="number">_</span>), <span class="symbol">do:</span> f</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(%{<span class="symbol">just:</span> fun}, f) <span class="keyword">do</span></div><div class="line">    f |> Control.Functor.fmap(fun)</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></table></figure><p><code>Maybe</code> is now a <code>Functor</code> as well as an <code>Applicative</code>. Again, our <code>Maybe</code> implementation of <code>Applicative</code> destructures the first argument, returning a “nothing” value if one is present. However, now it is expected that the value in our functor is a function of type <code>(term -> term)</code>. Here’s an example where this would be useful:<figure class="highlight elixir"><table><tr><td class="code"><pre><div class="line">f4 = <span class="keyword">fn</span> file -></div><div class="line">  <span class="keyword">case</span> File.stat(file) <span class="keyword">do</span></div><div class="line">    {<span class="symbol">:ok</span>, s} -></div><div class="line">      Maybe.just(&(&<span class="number">1</span> |> magic_function(s))</div><div class="line">    {<span class="symbol">:error</span>, <span class="number">_</span>} -></div><div class="line">      Maybe.nothing</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></table></figure><blockquote><p><em>I know this is a convoluted example with simpler alternatives. Let me know if you have a better example for this.</em></blockquote><p>In this specific case, we’ve created a closure over the <code>File.Stat</code> variable (<code>s</code>) using it in an eventual call to our <code>magic_function/2</code> function. We only want the call to <code>magic_function/2</code> to occur when the file actually exists, so <code>Maybe</code> comes in to save the day.<p>Because our anonymous function is wrapped in a <code>Maybe</code>, it might be tricky call this function with another <code>Maybe</code>. We could pull out the function manually:<figure class="highlight elixir"><table><tr><td class="code"><pre><div class="line"><span class="comment"># "something.txt" exists</span></div><div class="line">%Maybe{<span class="symbol">just:</span> f5} = f4.(<span class="string">"something.txt"</span>)</div></pre></table></figure><p>But this would need to be duplicated everywhere it was necessary. There also may be cases where this process would be too cumbersome to carry out manually. Lucky for us, the implementations of <code>Applicative.apply/2</code> will handle this for all functors that have it available.<figure class="highlight elixir"><table><tr><td class="code"><pre><div class="line">f4.(<span class="string">"something.txt"</span>)</div><div class="line">|> Applicative.apply(Maybe.just(<span class="number">5</span>))</div></pre></table></figure><h2 id="Monad"><a href="#Monad"class="headerlink"title="Monad"></a>Monad</h2><p>While I definitely don’t want to go down the “let’s describe what a monad is” road, I will say I’ve read that it is best to think of a monad as an abstract data type of actions. A list monad represents actions on a list. An IO monad represents actions on IO.<figure class="highlight elixir"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defprotocol</span> <span class="title">Monad</span></span> <span class="keyword">do</span></div><div class="line">  <span class="variable">@spec</span> bind(t, (term -> t)) <span class="symbol">:</span>: t</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">bind</span></span>(m, fun)</div><div class="line"><span class="keyword">end</span></div></pre></table></figure><p>Without going into detail just yet on <code>Monad</code>, did you notice any similarities to <code>Functor</code> and <code>Applicative</code>? Here are their typespecs right next to each other (expanding <code>Applicative</code>‘s to clear it up):<figure class="highlight elixir"><table><tr><td class="code"><pre><div class="line"><span class="variable">@spec</span> fmap( t, (term -> term)) <span class="symbol">:</span>: t             <span class="comment"># Functor</span></div><div class="line"><span class="variable">@spec</span> apply(t [(term -> term)], Functor.t) <span class="symbol">:</span>: t <span class="comment"># Applicative</span></div><div class="line"><span class="variable">@spec</span> bind( t, (term -> t)) <span class="symbol">:</span>: t                <span class="comment"># Monad</span></div></pre></table></figure><p>They all accept a value and a function to modify that value, returning the type again.<p>In <code>Functor.fmap/2</code>, we take an unwrapped value, apply the function, and return a wrapped result. In <code>Applicative.apply/2</code>, we do the same as <code>Functor.fmap/2</code>, but the function is wrapped as well as the value. In <code>Monad.bind/2</code>, we do the same as <code>Functor.fmap/2</code> as well, but the function argument returns the wrapped value opposed to it being wrapped after the fact.<figure class="highlight elixir"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defimpl</span> <span class="title">Monad</span></span>, <span class="symbol">for:</span> Maybe <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">bind</span></span>(%{<span class="symbol">nothing:</span> <span class="keyword">true</span>} = f, <span class="number">_</span>), <span class="symbol">do:</span> f</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">bind</span></span>(%{<span class="symbol">just:</span> v}, fun) <span class="keyword">do</span></div><div class="line">    fun |> apply([v])</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></table></figure><p>Following the types, the implementation for <code>bind/2</code> looks very similar to that of <code>fmap/2</code> and <code>apply/2</code> because they are all similar. The difference come down to how the functions receive the data and how it expects the function to transform that data.<h2 id="Wrapping-Up"><a href="#Wrapping-Up"class="headerlink"title="Wrapping Up"></a>Wrapping Up</h2><p>In my eyes, it’s yet to be determined whether or not Elixir and Erlang really need functors, applicatives, and monads. The data types that follow these protocols can structure things in a way so that they can hide state, side-effects, etc. away from the pure side of the code, and Haskell uses them to it’s advantage to become more than just an academic language and to be able to solve real world problems.<p>But since Elixir is a dynamic language, we don’t always have the compiler to tell us what to do. We can add side-effecting code in our pure functions and others would be none the wiser, but typically, Elixir and Erlang developers will hide the same state, side-effects, etc. away into designated actors. There’s no need for a <code>State</code> monad to maintain state between function calls because we have abstractions around actors like <code>GenServer</code> and <code>Agent</code> to do this for us, interfacing with those actors by message passing.<p>I’m going to keep going down this adventurous path for a little while longer, but I don’t quite yet see how many cases that I’d use these in lieu of actors.<blockquote><p>If you’re interested in seeing the code behind this post, take a look at <a href="https://github.com/slogsdon/elixir-control"rel="external"target="_blank"><code>Control</code></a>, an exploratory look into functors, applicatives, and monads for Elixir.</blockquote><script>var classes={".content a":["black-70"],".content p, .content ul, .content ol":["measure"],".post .content > p:first-of-type":["f4"],".content blockquote":["ml3","pl3","bl","b--black-10","bw4"]};for(var selector in classes)if(classes.hasOwnProperty(selector)){var contents=document.querySelectorAll(selector);Array.prototype.slice.call(contents).map(function(t){classes[selector].map(function(e){t.classList.add(e)})})}</script></section><footer class="b--black-10 bt bb mt4 post-footer"><p class="meta tags"><span class="label">tags:</span> <a href=""class="black-70 ml3">functional programming</a> <a href=""class="black-70 ml3">elixir</a> <a href=""class="black-70 ml3">haskell</a></footer></article></main><footer class="mv4 footer db-l dn"><p class="dib mr3 copyright"><small>© 2017 Shane Logsdon</small><p class="dib mr3 rss-subscribe"><small>subscribe <a href="/feed.xml"class="black-70">via RSS</a></small><p class="dib mr3 toggle-ligatures"><small><a href="javascript:toggleLigatures();"class="black-70">toggle code ligatures</a></small><script>function toggleLigatures(){return-1===document.body.className.indexOf("fira-code")?void(document.body.className+=" fira-code"):void(document.body.className=document.body.className.replace(" fira-code",""))}</script></footer></div><header class="b--black-10 bt bn-l dib-ns f6 fl-l header lh-copy ml3-l mt1-l mt3 tc v-top-ns w-100 w-20-l"><div class="mv4 mv5-l"><a href="/"class="black-70 b f3-l f4"title="Home"id="menu">Shane Logsdon<div><small class="f6 normal">Polyglot Developer</small></div></a></div><nav class="b--black-10 bt bb mv4 mv5-l page-nav"><ul class="list pl1"><li class="di"><a href="/"class="black-70 mr3 page-link">Home</a><li class="di"><a href="/posts/"class="black-70 mr3 page-link">Posts</a><li class="di"><a href="/projects/"class="black-70 mr3 page-link">Projects</a><li class="di"><a href="/presentations/"class="black-70 mr3 page-link">Presentations</a><li class="di"><a href="/about/"class="black-70 mr3 page-link">About</a></ul></nav><p class="mv4-l description ma3">I develop things. Sometimes, I write about them here. Let's start a conversation.<nav class="mv3 interaction-nav pb3"><ul class="list contact-list tl"><li class="mv1">Email me: <a href="mailto:shane@logsdon.io"class="black-70"rel="noopener"target="_blank">shane@logsdon.io</a><li class="mv1">Develop with me: <a href="https://github.com/slogsdon"class="black-70"title="GitHub"rel="noopener"target="_blank">slogsdon</a><li class="mv1">Tweet me: <a href="https://twitter.com/shanelogsdon"class="black-70"title="Twitter"rel="noopener"target="_blank">shanelogsdon</a></ul></nav><nav class="mv3 mv4-l tag-nav">Tags<ul class="list tag-list tj"><li class="dib ma1"><a href="/tag/net/"class="black-70">.net</a><li class="dib ma1"><a href="/tag/acvte/"class="black-70">acvte</a><li class="dib ma1"><a href="/tag/apache/"class="black-70">apache</a><li class="dib ma1"><a href="/tag/api/"class="black-70">api</a><li class="dib ma1"><a href="/tag/authentication/"class="black-70">authentication</a><li class="dib ma1"><a href="/tag/azure/"class="black-70">azure</a><li class="dib ma1"><a href="/tag/bcrypt/"class="black-70">bcrypt</a><li class="dib ma1"><a href="/tag/chicagoboss/"class="black-70">chicagoboss</a><li class="dib ma1"><a href="/tag/csharp/"class="black-70">csharp</a><li class="dib ma1"><a href="/tag/deployment/"class="black-70">deployment</a><li class="dib ma1"><a href="/tag/devops/"class="black-70">devops</a><li class="dib ma1"><a href="/tag/docker/"class="black-70">docker</a><li class="dib ma1"><a href="/tag/elixir/"class="black-70">elixir</a><li class="dib ma1"><a href="/tag/erlang/"class="black-70">erlang</a><li class="dib ma1"><a href="/tag/exrm/"class="black-70">exrm</a><li class="dib ma1"><a href="/tag/fsharp/"class="black-70">fsharp</a><li class="dib ma1"><a href="/tag/functional-programming/"class="black-70">functional programming</a><li class="dib ma1"><a href="/tag/genevent/"class="black-70">genevent</a><li class="dib ma1"><a href="/tag/golang/"class="black-70">golang</a><li class="dib ma1"><a href="/tag/hardware/"class="black-70">hardware</a><li class="dib ma1"><a href="/tag/haskell/"class="black-70">haskell</a><li class="dib ma1"><a href="/tag/homebrew/"class="black-70">homebrew</a><li class="dib ma1"><a href="/tag/http/"class="black-70">http</a><li class="dib ma1"><a href="/tag/javascript/"class="black-70">javascript</a><li class="dib ma1"><a href="/tag/linux/"class="black-70">linux</a><li class="dib ma1"><a href="/tag/mandrill/"class="black-70">mandrill</a><li class="dib ma1"><a href="/tag/migration/"class="black-70">migration</a><li class="dib ma1"><a href="/tag/mysql/"class="black-70">mysql</a><li class="dib ma1"><a href="/tag/nginx/"class="black-70">nginx</a><li class="dib ma1"><a href="/tag/obtvse2/"class="black-70">obtvse2</a><li class="dib ma1"><a href="/tag/payments/"class="black-70">payments</a><li class="dib ma1"><a href="/tag/percona/"class="black-70">percona</a><li class="dib ma1"><a href="/tag/phalcon/"class="black-70">phalcon</a><li class="dib ma1"><a href="/tag/php/"class="black-70">php</a><li class="dib ma1"><a href="/tag/rails/"class="black-70">rails</a><li class="dib ma1"><a href="/tag/redirects/"class="black-70">redirects</a><li class="dib ma1"><a href="/tag/review/"class="black-70">review</a><li class="dib ma1"><a href="/tag/ruby/"class="black-70">ruby</a><li class="dib ma1"><a href="/tag/rust/"class="black-70">rust</a><li class="dib ma1"><a href="/tag/sockets/"class="black-70">sockets</a><li class="dib ma1"><a href="/tag/talk/"class="black-70">talk</a><li class="dib ma1"><a href="/tag/testing/"class="black-70">testing</a><li class="dib ma1"><a href="/tag/vagrant/"class="black-70">vagrant</a><li class="dib ma1"><a href="/tag/wordpress/"class="black-70">wordpress</a><li class="dib ma1"><a href="/tag/workshop/"class="black-70">workshop</a></ul></nav></header><footer class="mv4 footer db dn-l"><p class="dib mr3 copyright"><small>© 2017 Shane Logsdon</small><p class="dib mr3 rss-subscribe"><small>subscribe <a href="/feed.xml"class="black-70">via RSS</a></small><p class="dib mr3 toggle-ligatures"><small><a href="javascript:toggleLigatures();"class="black-70">toggle code ligatures</a></small><script>function toggleLigatures(){return-1===document.body.className.indexOf("fira-code")?void(document.body.className+=" fira-code"):void(document.body.className=document.body.className.replace(" fira-code",""))}</script></footer><noscript id="deferred-styles"><link href="/assets/css/main.css"rel="stylesheet"media="all"></noscript><script>var loadDeferredStyles=function(){var e=document.getElementById("deferred-styles"),t=document.createElement("div");t.innerHTML=e.textContent,document.body.appendChild(t),e.parentElement.removeChild(e)},raf=requestAnimationFrame||mozRequestAnimationFrame||webkitRequestAnimationFrame||msRequestAnimationFrame;raf?raf(function(){window.setTimeout(loadDeferredStyles,0)}):window.addEventListener("load",loadDeferredStyles)</script>